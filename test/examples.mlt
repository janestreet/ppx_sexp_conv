module Position_for_polymorphic_variant_errors = struct
  type t1 = [ `A ] [@@deriving of_sexp]
  type t2 = [ `B ] [@@deriving of_sexp]
  type t3 = A of [ t1 | t2 ] [@@deriving of_sexp]

  let (_ : t3) = t3_of_sexp (List [ Atom "A"; Atom "C" ])
end

[%%expect
  {|
Exception:
(Of_sexp_error
  "examples.mlt.Position_for_polymorphic_variant_errors.t3_of_sexp: no matching variant found"
  (invalid_sexp C))
|}]

let _ = [%sexp_of: 'a]

[%%expect
  {|
Line _, characters _-_:
Error: ppx_sexp_conv: unbound type variable 'a
|}]

let _ = [%sexp_of_stack: 'a]

[%%expect
  {|
Line _, characters _-_:
Error: ppx_sexp_conv: unbound type variable 'a
|}]

let _ = [%of_sexp: 'a]

[%%expect
  {|
Line _, characters _-_:
Error: ppx_sexp_conv: unbound type variable 'a
|}]

module type S = sig
  val x : [%sexp_of: 'a]
end

[%%expect {| |}]

module type S = sig
  val x : [%sexp_of_stack: 'a]
end

[%%expect {| |}]

let _ = [%sexp (() : 'a)]

[%%expect
  {|
Line _, characters _-_:
Error: ppx_sexp_conv: unbound type variable 'a
|}]

type 'a t =
  | None
  | Something_else of { value : 'a }
[@@deriving sexp ~stackify]

[%%expect {| |}]

module Record_with_defaults = struct
  open Sexplib0.Sexp_conv

  let a_field = "a_field"
  let b_field = "b_field"

  type record_with_defaults =
    { a : string [@default a_field]
    ; b : string [@default b_field]
    }
  [@@deriving of_sexp]
end

[%%expect {| |}]

module Polymorphic_recursion = struct
  type 'a t = T of 'a t t [@@deriving sexp_grammar]
end

[%%expect {| |}]

module type Sexpable = sig
  type t [@@deriving sexp]
end

module Define_sexp_converters_manually : sig
  type t [@@deriving sexp]

  module Functor (M : Sexpable) : Sexpable with type t = t
  module T : Sexpable with type t = t

  type with_functor = { x : Functor(T).t } [@@deriving sexp]

  module Parameterized : sig
    type 'a t [@@deriving sexp]
  end
end = struct
  open Base

  type t = unit

  let [%sexp_of: t] = [%sexp_of: unit]
  let [%of_sexp: t] = [%of_sexp: unit]

  module T = struct
    type nonrec t = t

    let [%sexp_of: t] = [%sexp_of: t]
    let [%of_sexp: t] = [%of_sexp: t]
  end

  module Functor (M : Sexpable) = struct
    module _ = M

    type nonrec t = t [@@deriving sexp]
  end

  (* the raison d'etre *)
  let [%sexp_of: Functor(T).t] = fun (module M : Sexpable) -> [%sexp_of: t]
  let [%of_sexp: Functor(T).t] = fun (module M : Sexpable) -> [%of_sexp: t]

  type with_functor = { x : Functor(T).t } [@@deriving sexp]

  module Parameterized = struct
    type 'a t = 'a * 'a

    let [%sexp_of: a t] = fun [%sexp_of: a] -> [%sexp_of: a * a]
    let [%of_sexp: a t] = fun [%of_sexp: a] -> [%of_sexp: a * a]
  end
end

[%%expect {| |}]

(* Banning this is fine because it's also banned in expression position. *)
let [%sexp_of: 'a] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Type variables are disallowed here. Instead, consider using a locally
       abstract type.
|}]

(* Banning this is fine because it's also banned in expression position. *)
let [%of_sexp: 'a] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Type variables are disallowed here. Instead, consider using a locally
       abstract type.
|}]

let [%sexp_of: _] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Only type constructors are allowed here (e.g. [t], ['a t], or
       [M(X).t]).
|}]

let [%of_sexp: _] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Only type constructors are allowed here (e.g. [t], ['a t], or
       [M(X).t]).
|}]

let [%sexp_of: M.N(X).t] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Invalid identifier M.N(X).t for converter in pattern position. Only
       simple identifiers (like t or string) or applications of functors with
       simple identifiers (like M(K).t) are supported.
|}]

let [%of_sexp: M.N(X).t] = ()

[%%expect
  {|
Line _, characters _-_:
Error: Invalid identifier M.N(X).t for converter in pattern position. Only
       simple identifiers (like t or string) or applications of functors with
       simple identifiers (like M(K).t) are supported.
|}]
